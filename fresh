#!/bin/bash
#

function freshlog {
	echo "fresh log | $(date '+%Y-%m-%d %H:%M:%S') | $* "
}

## ANSI art :-)
function intro {
	echo " __                _"
	echo "/ _|              | |"
	echo "| |_ _ __ ___  ___| |___"
	echo "|  _| '__/ _ \/ __| '_  \ "
	echo "| | | | |  __/\__ \ | | |"
	echo "|_| |_|  \___||___/_| |_|"
	echo ""
}

intro

function exciting {
#	freshlog "# ------------------ #"
#	freshlog "# Pipelines Complete #"
#	freshlog "# ------------------ #"
	echo ""
	echo "               _ _   _             "
	echo "              (_) | (_)            "
	echo "  _____  _____ _| |_ _ _ __   ____ "
	echo " / _ \ \/ / __| | __| | '_ \ / _  |"
	echo "|  __/>  < (__| | |_| | | | | (_| |"
	echo " \___/_/\_\___|_|\__|_|_| |_|\__, |"
	echo "                              __/ |"
	echo "                             |___/ "
	echo ""
	exit 0
}

function usage {

echo " _   _ ___  __ _  __ _  ___  "
echo "| | | / __|/ _\` |/ _\` |/ _ \ "
echo "| |_| \__ \ (_| | (_| |  __/ "
echo " \__,_|___/\__,_|\__, |\___| "
echo "                  __/ |      "
echo "                 |___/ "

	cat << EOF

Bash scripting to automate FreeSurfer usage
Use at your own risk, no warranty is provided
Flags explained
	-s <Subject ID>
	-d <Directory where subject data is located>
			[if not specified assumes current directory]
	-f <NII file to work on>
			(multiple instances of this flag possible)
	-w <wave/time_series>
			(multiple instances of this flag possible)
	-k [If this flag is used the recon-all -all pipelines are skipped]
	-l [If this flag is used the longitudinal pipelines are skipped]
	-r [If this flag is used the data has NOT been resampled]
	-t [If this flag is used there are T2 images]
	-n <number of processor cores to work with for parallel pipelines>
			[if not set defaults to slurm setting]
	-a <afni input file>
	-z <afni output file>
	-p [If this flag is passed ONLY the recon-all -i steps will be done]
			[No other pipelines will be carried out]
			[And this only works on one file and time series / wave at a time]
	-c <specify output file for mri_convert to convert -f reference to>
	-u [Print this help message]
	-h [Print this help message]

EOF

exciting

}

function sane {
		freshlog "Doing - $*"
		"$@"
		local status=$?
		if [ $status -ne 0 ]; then
				freshlog "**** ERROR WITH: $1" >&2
				freshlog "Exiting because of the previous error"
				exit 101
		fi
		#return $status
		freshlog "Done"
}

function env_setup {

	. /etc/profile.d/modules.sh
	module purge
	module load tcin apps fresh

	if [ "$1" = "stable" ]; then
			freshlog "Loading stable FreeSurfer module"
			module load freesurfer/6.0
	elif [ "$1" == "dev" ]; then
		freshlog "Loading development FreeSurfer module"
		module load freesurfer/6-dev-20180918
		export ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=$cores
	elif [ "$1" == "afni" ]; then
		freshlog "Loading AFNI module"
		module load afni/17.1.03
	fi

	freshlog "Loaded module(s) are:"
	module list

}

function mri_convert {
	freshlog "-c flag passed"
	freshlog "Running mri_convert on $file and outputting as $convertedoutputfile"
	if [ "$t2_images_present" != "YES" ]; then
		env_setup stable
		## FIXME NB - ability to run mri_convert on multiple files
		## Currently can only work on 1
		#if [ ${#files[@]} -eq 1 ]; then
			## single file available to process here
			## this is OK for now
			for file in "${files[@]}"
			do
				#sane mri_convert -cs 0.9 "$file" "$convertedoutputfile"
				# _RS appended at end of resampled files so just this might work
				sane mri_convert -cs 0.9 "$file" "$file""_RS"
			done
		#fi
	fi
}

function afni_processing {

## AFNI sanity checks

	if [ ! -f "$afni_input" ]; then
		freshlog "AFNI processing specified with -a flag"
		freshlog "No AFNI input file specified with -a"
		freshlog "Exiting"
		exit 111
	fi

	if [ ! -f "$afni_output" ]; then
		freshlog "AFNI processing specified with -z flag"
		freshlog "No AFNI output file specified with -z"
		freshlog "Exiting"
		exit 112
	fi

	env_setup afni

	## FIXME - way to pass specific AFNI flags
	sane 3dresample -orient ras -dxyz 1.2 1.1 1.1 -prefix "$afni_output" -input "$afni_input"

	# *3dresample* -*orient* ras *-dxyz* 1.2 1.1 1.1 *-prefix* <output_name> *-input* <input_name>
	# (those in bold are part of the command, those in normal are the
	# parameters people can change according to their data)

}

function do_recon_all_prefix {
	## this is a short step
	freshlog "# -------------------------------------------------- #"
	freshlog "Starting recon-all -i prepend steps"
	freshlog "This will only run recon-all -i on a single File for,"
	freshlog "a single Subject ID at a single Time Point."

	## sanity check
	if [ ! -d "$subject""_""$wave" ]; then
		freshlog "The output directory from the recon-all -i does not appear to exist"
		freshlog "recon-all i output directory is: "$subject""_""$wave""
		freshlog "This is naive as it assumes the mere existance of the directory"
		freshlog "proves all is well."
		freshlog "Doing the pre-processing step"

		env_setup stable

		#for wave in "${waves[@]}"
		#for file in "${files[@]}"
		#do
			## REFERENCE - leaving here for now incase we need to return to this
			#sane recon-all -i "$file" -s "$subject""_""$wave"
		#done

		index="0"
		while [ "$index" -lt "$file_count" ]
		do
			## Iterate through one array, (files), to get its corresponding item in a second array (waves)
			thisfile=$(echo "${files[$index]}")
			thiswave=$(echo "${waves[$index]}")
			thisresampledfile=""$thisfile""_RS""
				# `--> mri_convert step has renamed these files, this resampling step needs to happen to all current data
			freshlog "Iterating through index point: $index of the files array to get the file to work on:"
			freshlog "Which is: $thisfile"
			freshlog "To get its corresponding $index item in the waves array to get the wave to work on: $thiswave"
			sane recon-all -i "$thisresampledfile" -s "$subject""_""$thiswave"
			((index++))
		done

		freshlog "Finished recon-all -i PREPEND ONLY steps for"
		freshlog ""$subject""_""$wave""
		freshlog "Work complete."
		freshlog "# -------------------------------------- #"
		freshlog ""

	else
		freshlog "The output directory from the recon-all -i does appears to exist"
		freshlog ""$subject""_""$wave""
		freshlog "Moving on without doing pre-processing step"
	fi

	}

function do_recon_all {

	freshlog "# --------------------------- #"
	freshlog "Starting recon-all -all steps"

	env_setup stable

	for wave in "${waves[@]}"
	do
		if [ "$t2_images_present" == "YES" ]; then
				# T2 there are T2 images, so proceess accordingly
				sane recon-all -all -3T -parallel -openmp "$cores" -T2 "$subject""_""$wave""_T2_GR_FP.nii.gz" -T2pial -s "$subject""_""$wave" -hippocampal-subfields-T1T2 T1andT2_based
		else
				# T1 - there are NO T2 images, so proceess accordingly
			sane recon-all -all -3T -parallel -openmp "$cores" -s "$subject""_""$wave" -hippocampal-subfields-T1
		fi
	done

	env_setup dev

	for wave in "${waves[@]}"
	do
		sane segmentHA_T1.sh "$subject""_""$wave"
		sane segmentBS.sh "$subject""_""$wave"
		sane segmentThalamicNuclei.sh "$subject""_""$wave"
	done

	## T2 step - Not needed for F
	#segmentHA_T2.sh $subject $directory/$subject_w1_T2_FP.nii.gz T1andT2_based 1
if [ "$t2_images_present" == "YES" ]; then
	for wave in "${waves[@]}"
	do
		segmentHA_T2.sh $subject $directory/"$subject""_""$wave""_T2_GR_FP.nii.gz" T1andT2_based 1
	done
fi

	freshlog "recon-all steps completed"
	freshlog "# ----------------------- #"

}

function do_longitudianal {

	freshlog "# ------------------------ #"
	freshlog "Starting Longitudianal Pipeline"

	## sanity check to ensure multiple time points here
	if [ ${#waves[@]} -gt 1 ]; then
		freshlog "Detected there are ${#waves[@]} time points, which is  more than 1 time series or wave"
		freshlog "I.e. this is longitudianal data - Moving on to process it longitudianally"

		env_setup stable

		## recon-all -base has the following format
		## recon-all -base "$subject""base" -tp $subject_$timepoint1 -tp $subject_timepoint2 -tp $subject_timepoint3 -all
		## thus we need to build an array of the waves and pass them to it
		for wave in "${waves[@]}"
		do
			local timepointrefs=("${timepointrefs[@]}" "-tp" "$subject""_""$wave")
		done

		sane recon-all -base "$subject""base" "${timepointrefs[@]}" -all

		lastwave=$(echo "${waves[*]}" | sort -nr | awk '{print $NF}')
		freshlog "Determining the last time series to be $lastwave"
			## `--> thought this step only ran on last time point but it runs on all
			##			keeping the variable incase it comes in useful elsewhere

		for wave in "${waves[@]}"
		do
			sane recon-all -long "$subject""_""$wave" "$subject""base" -all
		done

		env_setup dev

		freshlog "Starting segmentHA_T1_long.sh step"
		sane segmentHA_T1_long.sh "$subject"base

		freshlog "Starting segmentBS.sh steps"

		for wave in "${waves[@]}"
		do
			sane segmentBS.sh "$subject""_""$wave".long."$subject"base
		done

		freshlog "Finished segmentBS.sh steps"

		freshlog "Starting segmentThalamicNuclei.sh steps"

		for wave in "${waves[@]}"
		do
			sane segmentThalamicNuclei.sh "$subject""_""$wave".long."$subject"base
		done

		freshlog "Finished longitudianal steps"
		freshlog "# ------------------------ #"

	else
                freshlog "Detected there are ${#waves[@]} time points, which is less than 2 time series or waves"
                freshlog "I.e. this does not appear to be longitudianal data - Not running the longitudianal pipelines"
		freshlog ""
	fi
}

# get the flags
while getopts "s:d:f:w:c:a:z:n:rpklu" OPTION
do
	case $OPTION in
		s)
			subject=$OPTARG
			;;
		d)
			directory=$OPTARG
			;;
		f)
			files=(${files[@]} "$OPTARG")
			#file=$OPTARG
			;;
		w)
			waves=(${waves[@]} "$OPTARG")
			;;
		k)
			skip_reconall="YES"
			;;
		l)
			skip_longitudianal="YES"
			;;
		r)
			resampled="NO"
			;;
		t)
			t2_images_present="YES"
			;;
		c)
			convertedoutputfile=$OPTARG
			;;
		a)
			afni_input=$OPTARG
			;;
		z)
			afni_output=$OPTARG
			;;
		p)
			recon_all_prefix="YES"
			;;
		n)
			cores=$OPTARG
			;;
		?)
			usage
			exit
			;;
	esac
done

## Sanity Checks
for file in "${files[@]}"
do
	if [ ! -f "$file" ]; then
		freshlog "Can't find the file $file referenced with the -f flag"
		usage
		freshlog "Exiting without going furhter"
		exit 90
	else
		freshlog "Will be working on file: $file"
	fi
done

if [ -z "$subject" ]; then
	freshlog "No Subject ID provided via the -s flag"
	usage
	freshlog "Exiting without going furhter"
	exit 91
else
	freshlog "Subject ID = $subject"
fi

if [ ${#waves[@]} -eq 0 ]; then
	freshlog "No wave / time series reference provided via the -w flags"
	freshlog "Or no -w flags specified at all"
	usage
	freshlog "Exiting without going furhter"
	exit 92
else
	freshlog "Wave(s) = "
	echo "${waves[@]}"
fi

## make sure the number of files corresponds to the same number of waves
file_count=${#files[@]}
wave_count=${#waves[@]}
if [ "$file_count" != "$wave_count" ]; then
	freshlog "File count ("$file_count") is NOT equal to the Wave Count ("$wave_count")"
	freshlog "The number of files needs to correspond to the number of waves or time series"
	freshlog "Exiting without running any pipelines."
	exit 88
fi

if [ -z "$directory" ]; then
	directory=$(pwd)
fi
export SUBJECTS_DIR=$directory
freshlog "Setting directory to be $directory"
freshlog "Setting SUBJECTS_DIR = $directory"

## if not specified assuming the number of cores
## is being dictated by a slurm allocation
if [ -z "$cores" ]; then
	cores="$SLURM_TASKS_PER_NODE"
fi
freshlog "Number of Cores to work with = $cores"

## Worflow starts here

freshlog "# Pipelines Starting #"

if [ "$recon_all_prefix" == "YES" ]; then
	do_recon_all_prefix
	# this will exit after this
	exciting
fi

if [ -n "$convertedoutputfile" ]; then # string not null, hence doing mri_convert
	mri_convert
fi

if [ "$skip_reconall" == "YES" ]; then
	freshlog "Skipping recon-all -all steps"
else
	## the prefix function is conditional on the relevant directory not existing
	do_recon_all_prefix
	do_recon_all
fi

if [ "$skip_longitudianal" == "YES" ]; then
	freshlog "Skipping longitudianal steps"
else
	do_longitudianal
fi

exciting

exit 0
